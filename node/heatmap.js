/*
Renders a webpage page of contour maps representing eye data of unique participants
Written by Zelda Ferris
Some code was generated by Chat GPT then modified by Zelda Ferris
Some code is templated from the d3 documentation and modified by me
*/
// Define Constants
const width = 600;
const height = 300;
const middle_x = width * 0.5 - 130;

var file_names = [];

/*
CREATE DROP DOWNS
*/

var selectedHOO = "R";
var selectedS = "";
var selectedC = "";
var selectedInhi = "";
var selectedWM = "";


// HOO dropdown
const HOO_options = ["R", "L"];
d3.select("#HOO_button")
  .selectAll("HOO Options")
  .data(HOO_options)
  .enter()
  .append("option")
  .text(function (d) { return d; }) 
  .attr("value", function (d) { return d; });

d3.select("#HOO_button").on("change", function(d){
  selectedHOO = d3.select(this).property("value"); // get the selected HOO from the drop down
  console.log("hoo changed to ", selectedHOO)
  filter();
})

// Spacing dropdown
const S_options = ["No Spacing Filter", "Congruent Spacing", "Neutral Spacing", "Incongruent Spacing"]
d3.select("#S_button")
  .selectAll("S Options")
  .data(S_options)
  .enter()
  .append("option")
  .text(function (d) { return d; }) 
  .attr("value", function (d) { return d; });

d3.select("#S_button").on("change", function(d){
  selectedS = function(e) {
    var s = d3.select(this).property("value")
    if (s == S_options[0]) {
      return ""
    }
    if (s == S_options[1]) {
      return "CS"
    }
    if (s == S_options[2]) {
      return "NS"
    }
    else {
      return "IS"
    }
  }; // get the selected HOO from the drop down
  console.log("S changed to ", selectedS)
  filter();
})

// Color Dropdown
const C_options = ["No Color Filter", "Congruent Color", "Neutral Color", "Incongruent Color"]
d3.select("#C_button")
  .selectAll("C Options")
  .data(C_options)
  .enter()
  .append("option")
  .text(function (d) { return d; }) 
  .attr("value", function (d) { return d; });

d3.select("#C_button").on("change", function(d){
  selectedC = function(e) {
    var s = d3.select(this).property("value")
    if (s == C_options[0]) {
      return ""
    }
    if (s == C_options[1]) {
      return "CC"
    }
    if (s == C_options[2]) {
      return "NC"
    }
    else {
      return "IC"
    }
  }; // get the selected HOO from the drop down
  console.log("C changed to ", selectedC)
  filter();
})

// Inhibition Dropdown
const Inhi_options = ["No Inhibition Filter", "Low", "Average", "High"]
d3.select("#Inhi_button")
  .selectAll("Inhi Options")
  .data(Inhi_options)
  .enter()
  .append("option")
  .text(function (d) { return d; }) 
  .attr("value", function (d) { return d; });

d3.select("#Inhi_button").on("change", function(d){
  selectedInhi = d3.select(this).property("value");

  if (selectedInhi == "No Inhibition Filter") {
    selectedInhi = "";
  }; // get the selected HOO from the drop down
  console.log("Inhi changed to ", selectedInhi)
  filter();
})

// WM Dropdown
const WM_options = ["No Working Memory Filter", "Low", "Average", "High"]
d3.select("#WM_button")
  .selectAll("WM Options")
  .data(WM_options)
  .enter()
  .append("option")
  .text(function (d) { return d; }) 
  .attr("value", function (d) { return d; });

  d3.select("#WM_button").on("change", function(d){
    selectedWM = d3.select(this).property("value");
  
    if (selectedWM == "No Working Memory Filter") {
      console.log("if true")
      selectedWM = "";
    }; // get the selected HOO from the drop down
    console.log("Wm changed to ", selectedWM)
    filter();
  })

/*
RENDER STIMULI
*/

const stimuli_R = [
  { src: "stimuli/3.png", x: middle_x + 150, y: height * .2 },
  { src: "stimuli/6.png", x: middle_x, y: height * .2 },
  { src: "stimuli/9.png", x: middle_x - 150, y: height * .2 },
  { src: "stimuli/add.png", x: middle_x - 80, y: height * .2 },
  { src: "stimuli/div.png", x: middle_x + 80, y: height * .2 }
];

const stimuli_L = [
    { src: "stimuli/9.png", x: middle_x + 150, y: height * .2 },
    { src: "stimuli/3.png", x: middle_x, y: height * .2 },
    { src: "stimuli/6.png", x: middle_x - 150, y: height * .2 },
    { src: "stimuli/div.png", x: middle_x - 80, y: height * .2 },
    { src: "stimuli/add.png", x: middle_x + 80, y: height * .2 }
  ];

  // Add stimuli images
function add_stimuli(svg, stimuli){
    stimuli.forEach(stimulus => {
        svg.append("image")
          .attr("xlink:href", stimulus.src)
          .attr("x", stimulus.x)
          .attr("y", stimulus.y)
          .attr("height", .3 * height)
          .attr("width", .35 * width);
      });

  }

/*
READ DATA
*/
var participantData = {}

function getPIDs() {
    // Read and create an object to store EF data
    d3.csv("ace_data_levels.csv", d => ({
      pid: d.pid,
      inhibition: d.inhibition,
      wm: d.wm
    })).then(data => {
      // Create a lookup table
      data.forEach(d => {
        participantData[d.pid] = {
          inhibition: d.inhibition,
          wm: d.wm
        };
      });
  });
  console.log(participantData)
}

function getFiles() {
  console.log(selectedHOO)


// Fetch all CSV files from the server
  fetch('/api/files')
  .then(res => res.json())
  .then(files => {
    console.log("got files")
    files.forEach((filename, i) => {
      file_names.push(filename);
    });
    filter();
  });
}

/* 
FILTER DATA
*/
function filter() {
  d3.select("#container").selectAll("*").remove();
  file_names.forEach((filename, i) => {
    if (checkEF(filename)) {
      d3.csv(`AOI_hit/${filename}`, d => ({
        timestamp: +d.timestamp,
        x: +d.x * .4,
        y: +d.y * .35,
        Trackloss: d.Trackloss?.trim().toLowerCase(),
        Hit_AOIs: d.Hit_AOIs ? d.Hit_AOIs.split(",").map(a => a.trim()) : [],
        Problem_id: d.Problem_id,
      })).then(data => {
        console.log(selectedS)
        const filtered = data.filter(d => d.Trackloss !== "missing" 
          && d.Problem_id.includes(selectedHOO, selectedS, selectedC));
        renderChart(filtered, filename, selectedHOO, i);
      });
    } else { 
      // Do nothing
      } 
  });
}

function checkEF(filename) {
  f_pid = filename.replace("_AOI_Hit.csv", "").toLowerCase().replace("_", "");
  const participant = participantData[f_pid]

  if(participant) {
    
    return (participant.inhibition.includes(selectedInhi) && participant.wm.includes(selectedWM))
  }

}

/*
RENDER ONE CHART
*/
function renderChart(data, title, HOO, index) {

  //var HOO = "right"
  if (index == 1) {
    console.log(HOO)
  }
  const container = d3.select("#container")
    .append("div")
    .attr("class", "chart-wrapper");

  container.append("h4").text(title);

  const svg = container.append("svg")
    .attr("width", width)
    .attr("height", height);

  const contours = d3.contourDensity()
    .x(d => d.x)
    .y(d => d.y)
    .size([width, height])
    .bandwidth(20)
    .thresholds(10)
    (data);

  const color = d3.scaleSequential(d3.interpolateRdBu)
    .domain(d3.extent(contours, d => d.value))
    .nice();

  svg.append("g")
    .attr("fill", "none")
    .attr("stroke", "black")
    .attr("stroke-linejoin", "round")
    .selectAll("path")
    .data(contours)
    .join("path")
    .attr("stroke-width", (d, i) => i % 5 ? 0.25 : 1)
    .attr("d", d3.geoPath())
    .attr("fill", d => color(d.value))
    .attr("fill-opacity", 0.7);

  add_stimuli(svg, HOO == "R" ? stimuli_R : stimuli_L);

}

/*
RUN PROGRAM
*/
getPIDs();
getFiles();
